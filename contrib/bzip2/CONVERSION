1. Move the code we want to isolate to its own compilation unit. This
   is so we can use compile-time errors to detect any interactions
   with the rest of the code.

   In this case, we want to wrap the code that interacts with the
   compression and decompression library. A visual inspection shows
   that this is just the functions compressStream(),
   uncompressStream() and testStream().

2. Compile.

   Obviously we will now get errors because of the missing
   functions. Add them to an appropriate new header.

3. Compile.

   Now the first error is:

   "bzip2.c:746: warning: 'applySavedFileAttrToOutputFile' defined but
   not used"

   Without even looking, it is apparent that this function must only
   be used from the wrapped code.

   This function requires authority (it needs to be able to chmod), so
   we have a choice: grant that authority to the wrapped functions, or
   create a capability for it. We choose the latter.

   This is accomplished by allowing the child to call the function
   remotely, by using RPC over a pipe. For now, we only implement the
   parent's side of that - i.e. unmarshalling the arguments, calling
   the function, and returning a return code.

   A small amount of inspection reveals that only the output file
   should be chmod()ed, so we enforce that.

   At this point we also need to include utility code that will be
   part of Capsicum in the future.

4. The remaining unused functions do not require authority, so simply
   move them into the wrapped code.

5. Rename (so we don't accidentally invoke them direactly) and invoke
   the wrapped functions, handing in the capability they require (so
   far). If capability mode is not available, simply call the wrapped
   functions directly.

   Once this is done bzip2.c compiles cleanly once more. However, the
   link fails.
